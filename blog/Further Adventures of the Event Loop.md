##Further Adventures of the Event Loop - Erin Zimmer - JSConf EU 2018

youtube地址: https://www.youtube.com/watch?v=u1kqx6AenYw

英文原文：
a couple of years back, here at this very conference, a guy by the name of Phil Roberts did a talk called "what the hack of eventloop anyway?".if you haven't see it, I highly recommand you to check it out. It's on the JSConf youtube channel. It is pretty fucking exciting because it catches on fire. In case you haven't see it though, It is an overview of eventloop, the different components and how they work together. If you haven't see it, we will do a quick overview of the things that are relevent for today, and then we gonna do a deep dive into a specific parts of event loop. So, you can think of the eventloop as, like, the main function of the browser. It's just an infinite loop, It's going to grap a task of the task queue, and it's going to run that task, whick is great, but, what is a task? So, a task is how javascript gets run, If we had a bit of script like this, we can see JavaScript there, the browser will parse script tag and create the task. So the code of dark background is going to be a task, When it gets run, it's going to create a variable, it's going to do something, and it's going register this event listener, and then, whenever the browser gets a keydown event, the bit of blue is going to run as a task. Every bit of javascript that runs as a task could be a script or could be a callback.
What does the excute(task) do? It runs the code, it's really not important, if you want to knows, that's future's talk.But what about task queue, that's what we are going to talk about today, we are gona hava a look at task queues in the context of browsers and look at node, and we are gona have a real quick look at Web works. So what is task queue and what is it for? a task queue is where you code goes, where your JavaScript goes while it's waiting to excute. So, like before, we could parse a script tag, we could have callback on a click event, we could have a callback on setTimeout, or asynchronous request. They are going to go into our queue there and they're going to get excuted. The important thing is that it is a queue, so things are going to get excuted in the order of they arrive, first in, first out, and other important thing is that a task is going to run from start to the finish. There is no interrupted JavaScript, you don't have to worry about concurrency, locking or any of that rubbish, it is super easy, that's our event loop, it turns out, though, it's a little bit more complicated than that, the task queue works in conjunction with the rendering pipeline. The rendering pipeline is what it responsible for painting things in the browser window, so you make changes to the DOM, you update your style and then the rendering pipeline runs and shows it on the screen. So, the rendering pipeline can run after a task finishes, the task fineshes, the rendering pipeline can run, but browsers are pretty clever, right? They not like to do the work they don't have to do, and there is really no point running the rendering pipeline unless the screen's about to refresh, so your average screen refresh is 60 times a second, once every 16 milliseconds, so, if we running a task, the rendering pipeline is going to wait that 16 milliseconds before it runs. If it is not obvious, this is the slowed down version. It turns out it is hard to see, at 60 frames a second. Obviously sitting around doing nothing all that time is a bit of waste, so, in reality, the browser is going to run a bunch of tasks, and then running the rendering pipeline. The important thing is that the rendering pipeline can not run until the task finished, if you've got a task that takes a really long time, the rendering pipeline has to wait, a couple of milleseconds here and there isn't going to matter. But if you got tasks that takes a lot more than 16 millesecond, your webpage is going to start dropping frames and start running like this. If you do have long-running tasks, you can splite them up, so you can create new tasks using something like setTimeout. You can just run the firstPartOfTask and run the last later on, or you can use Web Workers because that's what they are for. So now, a event loop look like this, We are going to run a infinite loop, pick a task of the task queue and ru that task, and if we're ready to repaint, we will repaint.That's cool, right?
It turns out, it's a little bit more complicate than that, if you have a look at the spec which I'm sure we all do in our spare time. You will see an event loop it have one or more task queues. Now I have to say, at this point, what I will do is I will have a look at some extra browser code. I'm going to see like chromium does task queues, how manages them whatever, but, I have to xxx（坦白） with you, I am a JavaScript developer and it turns out the C++. It's mostly xxxx(难以理解), I, no ideal what's going on there.So, instead, we are going to look at theoretical browser with multiple task queues. To be clear, this is the example that is give in the spec of having multiple task queues. So I didn't made it up, somebody else made it up. This browser prioritises mouse click event, It's got two task queue there, it's got one where our mouse click is going to go and another queue where everything else goes. This is really simple, It's like the business class line at the airport. It's going to run all of the tasks in the mouse click queue, and then going to run tasks on the other queue. It doesn't affect the rendering pipeline which will run after each task if it wants to. It doesn't to be like that, right? The browser can  actually excute the queues in any order they like, so we could have taken two off the mouse click queue event and threee off the other queue, whatever we like. The queue can be excuted in any order.But, the queues still have to be queues, so the tasks have to be excuted in the order that they arrive, first in, first out. Tasks from the same source must go in the same queue.