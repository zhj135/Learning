##Further Adventures of the Event Loop - Erin Zimmer - JSConf EU 2018

youtube地址: https://www.youtube.com/watch?v=u1kqx6AenYw
ppt: https://ejzimmer.github.io/event-loop-talk/#/

英文原文：
a couple of years back, here at this very conference, a guy by the name of Phil Roberts did a talk called "what the hack of eventloop anyway?".if you haven't see it, I highly recommand you to check it out. It's on the JSConf youtube channel. It is pretty fucking exciting because it catches on fire. In case you haven't see it though, It is an overview of eventloop, the different components and how they work together. If you haven't see it, we will do a quick overview of the things that are relevent for today, and then we gonna do a deep dive into a specific parts of event loop. So, you can think of the eventloop as, like, the main function of the browser. It's just an infinite loop, It's going to grap a task of the task queue, and it's going to run that task, whick is great, but, what is a task? So, a task is how javascript gets run, If we had a bit of script like this, we can see JavaScript there, the browser will parse script tag and create the task. So the code of dark background is going to be a task, When it gets run, it's going to create a variable, it's going to do something, and it's going register this event listener, and then, whenever the browser gets a keydown event, the bit of blue is going to run as a task. Every bit of javascript that runs as a task could be a script or could be a callback.
What does the excute(task) do? It runs the code, it's really not important, if you want to knows, that's future's talk.But what about task queue, that's what we are going to talk about today, we are gona hava a look at task queues in the context of browsers and look at node, and we are gona have a real quick look at Web works. So what is task queue and what is it for? a task queue is where you code goes, where your JavaScript goes while it's waiting to excute. So, like before, we could parse a script tag, we could have callback on a click event, we could have a callback on setTimeout, or asynchronous request. They are going to go into our queue there and they're going to get excuted. The important thing is that it is a queue, so things are going to get excuted in the order of they arrive, first in, first out, and other important thing is that a task is going to run from start to the finish. There is no interrupted JavaScript, you don't have to worry about concurrency, locking or any of that rubbish, it is super easy, that's our event loop, it turns out, though, it's a little bit more complicated than that, the task queue works in conjunction with the rendering pipeline. The rendering pipeline is what it responsible for painting things in the browser window, so you make changes to the DOM, you update your style and then the rendering pipeline runs and shows it on the screen. So, the rendering pipeline can run after a task finishes, the task fineshes, the rendering pipeline can run, but browsers are pretty clever, right? They not like to do the work they don't have to do, and there is really no point running the rendering pipeline unless the screen's about to refresh, so your average screen refresh is 60 times a second, once every 16 milliseconds, so, if we running a task, the rendering pipeline is going to wait that 16 milliseconds before it runs. If it is not obvious, this is the slowed down version. It turns out it is hard to see, at 60 frames a second. Obviously sitting around doing nothing all that time is a bit of waste, so, in reality, the browser is going to run a bunch of tasks, and then running the rendering pipeline. The important thing is that the rendering pipeline can not run until the task finished, if you've got a task that takes a really long time, the rendering pipeline has to wait, a couple of milleseconds here and there isn't going to matter. But if you got tasks that takes a lot more than 16 millesecond, your webpage is going to start dropping frames and start running like this. If you do have long-running tasks, you can splite them up, so you can create new tasks using something like setTimeout. You can just run the firstPartOfTask and run the last later on, or you can use Web Workers because that's what they are for. So now, a event loop look like this, We are going to run a infinite loop, pick a task of the task queue and ru that task, and if we're ready to repaint, we will repaint.That's cool, right?
It turns out, it's a little bit more complicate than that, if you have a look at the spec which I'm sure we all do in our spare time. You will see an event loop it have one or more task queues. Now I have to say, at this point, what I will do is I will have a look at some extra browser code. I'm going to see like chromium does task queues, how manages them whatever, but, I have to xxx（坦白） with you, I am a JavaScript developer and it turns out the C++. It's mostly xxxx(难以理解), I, no ideal what's going on there.So, instead, we are going to look at theoretical browser with multiple task queues. To be clear, this is the example that is give in the spec of having multiple task queues. So I didn't made it up, somebody else made it up. This browser prioritises mouse click event, It's got two task queue there, it's got one where our mouse click is going to go and another queue where everything else goes. This is really simple, It's like the business class line at the airport. It's going to run all of the tasks in the mouse click queue, and then going to run tasks on the other queue. It doesn't affect the rendering pipeline which will run after each task if it wants to. It doesn't to be like that, right? The browser can  actually excute the queues in any order they like, so we could have taken two off the mouse click queue event and threee off the other queue, whatever we like. The queue can be excuted in any order.But, the queues still have to be queues, so the tasks have to be excuted in the order that they arrive, first in, first out. Tasks from the same source must go in the same queue, so all of our mouse click event have to go in that queue. Node use a specific queue for timeout event, so all of the timeout events have to go in that queue. So this is how our event loop looks like now, we've got a infinite loop, we are going to pick a queue, and then, it's time to repaint and we will repaint, cool, this is still very straightforward right? It's turns out, a little bit more complicated than that, though, we also have microtasks.
what's microtask? For the purposes of this 20 minutes talk, a microtask is a promise, there are other things that generate microtasks, but 99.9 percent of things that you gona do is going to be promises, so our microtask queue is in yellow there next to the rendering pipeline and we have a bit of code, it's going to run. we have promise that resolves. It goes in the microtask queue. Now, the microtask queue has a couple of special properties. First of all, it runs after every task, so you fininsh a task, then you run the microtask queue. Even if the rundering pipeline would like to run, it has to wait until the microtask queue finishes. If we have multiple tasks in microtask queue, they're all going to run, if we add more while we running it, those will have to be run too. So it has some importtant implications for how things run. Let's have a quick look at the difference between how tasks run and how microtasks run. So, this bit of code generate tasks, I click the buttton, it's going to print out the number of tasks that it has run, and then it's going to generate another task which is going to print out the number of tasks that is run so on and xx(不断循环). we can see it running, counting tasks, everything is great, I can select text, I can click stop button. I can't click start again because I didn't implement that. But, if we look at the same thing with microtasks, things a bit different.So if I start, this is the same code, right? It creating microtasks whick is going to print out the number of microtasks that have run. and then create another microtask and keep looping, the same as the setTimeout example but with promises. If I click start promising, we can see everything has immediately gone to shit. The button has clicked but hasn't unclicked, right? The cursor is still a little hand. I can't select text, I definitely can't click stop, which wouldn't helped because I didn't implement it. Anyway, it's like I knew what was going to happen, this page is kaput. If we wait a bit of longer, chrome will realise and tell us but I don't have that kind of time.
What happend there? Exactly like we saw the example, we are stuck, just dealing with the microtask queue. So the rest of event loop is blocked, we can't re-render the page, we can't do anything else. We are stuck in the microtask queue. 
This is how our event loop looks like now, it's an infinite loop, we are going to pick a queue, pick a task of that queue and run it. As long as there are microtasks to run, we are going to do microtasks, when that's done, if it's time to repaint, we will repaint.Cool, this is starting to look a little bit of complicated but it turns out that just a little bit more complicated than this. We also have the animation callback queue which I'm going to call the animation queue, because, if I keep saying the animation callback queue, this talk won't get finished in time for lunch. So, you can add things to the animation queue by calling requestAnimationFrame and passing a callback. Why would one do such a thing? I'm using here to run the animation of the browser window running into the pipeline. I have my browser window and pipeline and I remove a class which reset the frame and then I add the slide class to the window whick makes it slide down, through the magic of transitions.
If I did it like this, as I said before, browsers are clever, and they like to be helpful. If I wrote this code, the browser will look at it and say, you've removed the class and you've just add the same class back again. That's the same as doing nothing, so let's just do noting. So to do one, I need the window to refresh and then I need to do the next thing. We have a look about how that works. We've got our animation queue there in green besides the rendering pipeline. I've got my scripts running and I call requestAnimationFrame which adds something to the animation queue. You can see it's goint to sit there and nothing is going to happen until we are ready to repaint, then we will run the animation queue and then we will repaint the browser. Like the microtask queue, the animation queue has a couple of special properties. If I have mutiple things in the animation queue when it's ready to run, I'm going to run all those things. But, if I add more things to the animation queue while it's running I'm not going to run those guys. The reason for that is if you're creating animations, you want to this is what I want to do in this frame and then you're going to set up what is going to happen in the next frame but you don't want run it, right? You want to wait until the window has refreshed.
So, this is what our event loop looks like now. It's a infinite loop, we're going to pick a queue, we're going to grab the first task of that queue and we're going to run that task. Then as long as there are microtasks, we're going to run all those. Then, if we're ready to repaint, we're going to grab the animation tasks that are currently in the queue, and we're going to run all of those, and then we are going to repaint. And that is as complicated as it gets.
But, what about Node? First of all, some good news, Node is a lot simpler than a browser, it has no script-parsing events, you are not picking JavaScript out of HTML all over the place, you just give it a JavaScript file and it runs it. There is no users clicking on shit all over the place. You don't have to worry about animation framework callbacks becase there're no rendering pipeline. There is alse another important difference with Node, the browser event loop is like a merry-go-round. It's just keeps going round and round and round. The Node event loop, It's more like a roller coaster. It is going to run through one loop, and there's more stuff to do, it will run through another loop. Once it's down, that's it. It's down.
So, the Node event loop: Node has three queues that are interesting enough to talk about today. It's got one queue for your event callbacks, so your xhr requests, your disk reads and writes and all that kind of staff will go in the first queue. The second queue, they called phases in Node, so the second phase is the check phase. The third phase is your timers, so that's all your callbacks for setTimeout and setInterval will go into that third queue. Node is going to run everything in the event callback queue. Then it's going to run everything in the check queue. Once that's done, it's going to run everything in the timers queue. Then if there is more staff it will loop back around and run through the queues again. As soon as there is no task in any queues, and there are no event waiting anywhere, it will finish. It will end.
So, how do you add staff to the check phase? You can add things to the check phase queue by calling setImmediate and parsing a callback. setImmediate is the same as setTimeout with a time of zero, but because of the way the queues work, if you call setTimeout with a time of zero and setImmediate, your setImmediate is going to run first. Node also have promises, just like the browser, and Node promises work just the same as browser promises, after each task finishes, we will run the promise microtask queue. Node alse has another microtask queue whick is the nextTick queue, you can add things to the nextTick queue by calling process.nextTick and parsing a callback. It works just the same.There is nothing really interesting there. The major difference is, if you have both promises and nextTick callbacks, all of you nextTick callbacks will run before your promises, but that's pretty much of it. The only new things, differences in Node are setImmediate and process.nextTick if you have trouble remembering how they work, is easy, setImmediate, do something in the next tick, process.nextTick, do something immediately. Why they name like that? It turns out naming things are hard. You guys all know the two hard problems in computer science, right? Cation(?) validation and naming things and off by one errors.
So this is our Node eventloop. It's only going to run while there are still tasks. It's going pick a queue, and then, while that queue has more tasks, it's going to grab the next task in that queue, it's going to run that task, then while the nextTick queue has more tasks, it's going to run all the nextTick queue tasks, and then, while the promises queue has more tasks, it's going to do all the promises.
So that's just leave Web Workers. Anyone who is not familiar with Australian wildlife, this is a redback spider. Unlike most Australian wildlife, they are not that dangerous. Nobody died from the redback spider bite since the 1950s. Probably don't get bitten by one, though. So, Web Works, Web Works turn out to be dead simple. Each Web Work run in it's own thread. It's got it's own event loop, got it's own stack, task queue. Everythings just runs on it's own. It's even easier than Node. So there no script tags. Again you parse in a JavaScript file. There are no user interactions. Web Works aren't allowed to manipulate the DOM so you don't have to worry about any animation frames or anything like that. If we have a look at demo, we can generate tasks, call a setTimeout, make XHR requests, we can send and receive postMessage events. So postMessage is how your Web Work communicates with the browser window. And we can make promises. That's it, it's just really easy. So, that's the eventloop, things to remeber: long running tasks will make your web page run like a wonky cat. Promises and nextTick tasks can make it run like a dead cat. Make sure you break your tasks up into small pieces and don't have infinitely recursive promises and nextTick tasks. Node is a bit different to the browser. It's going to run through the eventloop only as long as there are things to do. It's got the three specific tasks, and it's got setImmediate and process.nextTick. Web Workers, they do their own thing, in their own eventloop, and completely separate from anything else that is going on. Remember, the event loop is more exciting than you could possibly have imagined. Thank you.

