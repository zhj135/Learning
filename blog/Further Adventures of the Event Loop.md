##Further Adventures of the Event Loop - Erin Zimmer - JSConf EU 2018

youtube地址: https://www.youtube.com/watch?v=u1kqx6AenYw

英文原文：
a couple of years back, here at this very conference, a guy by the name of Phil Roberts did a talk called "what the hack of eventloop anyway?".if you haven't see it, I highly recommand you to check it out. It's on the JSConf youtube channel. It is pretty fucking exciting because it catches on fire. In case you haven't see it though, It is an overview of eventloop, the different components and how they work together. If you haven't see it, we will do a quick overview of the things that are relevent for today, and then we gonna do a deep dive into a specific parts of event loop. So, you can think of the eventloop as, like, the main function of the browser. It's just an infinite loop, It's going to grap a task of the task queue, and it's going to run that task, whick is great, but, what is a task? So, a task is how javascript gets run, If we had a bit of script like this, we can see JavaScript there, the browser will parse script tag and create the task. So the code of dark background is going to be a task, When it gets run, it's going to create a variable, it's going to do something, and it's going register this event listener, and then, whenever the browser gets a keydown event, the bit of blue is going to run as a task. Every bit of javascript that runs as a task could be a script or could be a callback.
What does the excute(task) do? It runs the code, it's really not important, if you want to knows, that's future's talk.But what about task queue, that's what we are going to talk about today, we are gona hava a look at task queues in the context of browsers and look at node, and we are gona have a real quick look at Web works. So what is task queue and what is it for? a task queue is where you code goes, where your JavaScript goes while it's waiting to excute. So, like before, we could parse a script tag, we could have callback on a click event, we could have a callback on setTimeout, or asynchronous request. They are going to go into our queue there and they're going to get excuted. The important thing is that it is a queue, so things are going to get excuted in the order of they arrive, first in, first out, and other important thing is that a task is going to run from start to the finish. There is no interrupted JavaScript, you don't have to worry about concurrency, locking or any of that rubbish, it is super easy, that's our event loop, it turns out, though, it's a little bit more complicated than that, the task queue works in conjunction with the rendering pipeline. The rendering pipeline is what it responsible for painting things in the browser window, so you make changes to the DOM, you update your style and then the rendering pipeline runs and shows it on the screen. So, the rendering pipeline can run after a task finishes, the task fineshes, the rendering pipeline can run, but browsers are pretty clever, right? They not like to do the work they don't have to do, and there is really no point running the rendering pipeline unless the screen's about to refresh, so your average screen refresh is 60 times a second, once every 16 milliseconds, so, if we running a task, the rendering pipeline is going to wait that 16 milliseconds before it runs. If it is not obvious, this is the slowed down version. It turns out it is hard to see, at 60 frames a second. Obviously sitting around doing nothing all that time is a bit of waste, so, in reality, the browser is going to run a bunch of tasks, and then running the rendering pipeline. The important thing is that the rendering pipeline can not run until the task finished, if you've got a task that takes a really long time, the rendering pipeline has to wait, a couple of milleseconds here and there isn't going to matter. But if you got tasks that takes a lot more than 16 millesecond, your webpage is going to start dropping frames and start running like this